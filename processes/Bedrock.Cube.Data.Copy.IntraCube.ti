#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

# Revised process 23 December 2011

#####################################################################################
##~~Copyright bedrocktm1.org 2011 www.bedrocktm1.org/how-to-licence.php ~~##
#####################################################################################

# This is the INTRA process used to copy within a cube
# Not to be confused with the INTER process which is used to copy to a different cube

# The pFilter parameter contains the dimensons and elements to be used for filtering
# on dimensions that are not mapped
# In other words, dimensions where the source element is the same as the target element
# The format of the pFilter parameter is as follows (using default delimiters & + :
#     Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4
# The dimension parameters do not need to be given in the index order of dimensions in the cube.
# The dimension name is specified as the first member of the delimited string of elements.
# If consolidations are skipped the N level children of any consolidated filter elements will be used
# Spaces are ignored so use them to make your filter more readable

# The pElementMapping parameter is used for elements to be copied from a source element to a target element
# It uses the same pDimensionDelim and pElementStartDelim as pFilter
# but uses the pMappingDelimiter to separate the source element and target element
# e.g.
#     Dim1: SourceElement -> TargetElement & Dim2: SourceElement -> TargetElement
#
# The process adds the source elements used in the pElementMapping parameter to pFilter

# An example
# To copy the 2011 Actual data to 2012 Budget for Company ACME in the states of Utah and Nevada
# set pElementMapping to: Year:2011->2012 & Version:Actual->Budget
# and
# pFilter to: Company:ACME & State: Utah + Nevada
# The source will be filtered on 2011 Actual so you don't need to add 2011 Actual to the pFilter parameter

### Constants ###

cProcess = 'Bedrock.Cube.Data.Copy.IntraCube';
cTimeStamp = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt = NumberToString( INT( RAND( ) * 1000 ));
cDebugFile = GetProcessErrorFileDirectory | cProcess | '.' | cTimeStamp | '.';
cUser = TM1User();
sDelimDim = TRIM(pDimensionDelim);
sElementStartDelim = TRIM(pElementStartDelim);
sDelimElem = TRIM(pElementDelim);
sMappingDelimiter = TRIM(pMappingDelimiter);

sFilter = Trim(pFilter);
sTargetFilter = sFilter;

cSourceVariableStem = 'sSourceDim';
cTargetVariableStem = 'sTargetDim';
cMappedDimVariableStem = 'nMappedDim';

# nMappedDimX is a binary switch used to keep track of which dimensions have been mapped from the source to the target
nMappedDim1 = 0;
nMappedDim2 = 0;
nMappedDim3 = 0;
nMappedDim4 = 0;
nMappedDim5 = 0;
nMappedDim6 = 0;
nMappedDim7 = 0;
nMappedDim8 = 0;
nMappedDim9 = 0;
nMappedDim10 = 0;
nMappedDim11 = 0;
nMappedDim12 = 0;
nMappedDim13 = 0;
nMappedDim14 = 0;
nMappedDim15 = 0;
nMappedDim16 = 0;
nMappedDim17 = 0;
nMappedDim18 = 0;
nMappedDim19 = 0;
nMappedDim20 = 0;
nMappedDim21 = 0;
nMappedDim22 = 0;
nMappedDim23 = 0;
nMappedDim24 = 0;
nMappedDim25 = 0;
nMappedDim26 = 0;
nMappedDim27 = 0;

### Determine dimensions in target cube - we need to know this to test the cell type before loading ###
sDim1 = TabDim( pCube, 1 );
sDim2 = TabDim( pCube, 2 );
sDim3 = TabDim( pCube, 3 );
sDim4 = TabDim( pCube, 4 );
sDim5 = TabDim( pCube, 5 );
sDim6 = TabDim( pCube, 6 );
sDim7 = TabDim( pCube, 7 );
sDim8 = TabDim( pCube, 8 );
sDim9 = TabDim( pCube, 9 );
sDim10 = TabDim( pCube, 10 );
sDim11 = TabDim( pCube, 11 );
sDim12 = TabDim( pCube, 12 );
sDim13 = TabDim( pCube, 13 );
sDim14 = TabDim( pCube, 14 );
sDim15 = TabDim( pCube, 15 );
sDim16 = TabDim( pCube, 16 );
sDim17 = TabDim( pCube, 17 );
sDim18 = TabDim( pCube, 18 );
sDim19 = TabDim( pCube, 19 );
sDim20 = TabDim( pCube, 20 );
sDim21 = TabDim( pCube, 21 );
sDim22 = TabDim( pCube, 22 );
sDim23 = TabDim( pCube, 23 );
sDim24 = TabDim( pCube, 24 );
sDim25 = TabDim( pCube, 25 );
sDim26 = TabDim( pCube, 26 );
sDim27 = TabDim( pCube, 27 );

nErrors = 0;
nRulesDropped = 0;

### Initialise Debug ###

If( pDebug >= 1 );

  # Set debug file name
  sDebugFile = cDebugFile | 'Prolog.debug';

  # Log start time
  AsciiOutput( sDebugFile, 'Process Started: ' | TimSt( Now, '\d-\m-\Y \h:\i:\s' ) );

  # Log parameters
  AsciiOutput( sDebugFile, 'Parameters: pCube         : ' | pCube );
  AsciiOutput( sDebugFile, '            pView         : ' | pView );
  AsciiOutput( sDebugFile, '            pFilter           : ' | pFilter );
  AsciiOutput( sDebugFile, '            pElementMapping     : ' | pElementMapping );
  AsciiOutput( sDebugFile, '            pFactor     : ' | pFactor);

  AsciiOutput( sDebugFile, '            pDimensionDelim   : ' | pDimensionDelim );
  AsciiOutput( sDebugFile, '            pElementStartDelim: ' | pElementStartDelim );
  AsciiOutput( sDebugFile, '            pElementDelim     : ' | pElementDelim );
  AsciiOutput( sDebugFile, '            pMappingDelimiter     : ' | pMappingDelimiter );

  AsciiOutput( sDebugFile, '            pZeroTarget    : ' | NumberToString( pZeroTarget ) );
  AsciiOutput( sDebugFile, '            pZeroSource    : ' | NumberToString( pZeroSource ) );
  AsciiOutput( sDebugFile, '            pDeleteViewsAndSubsets    : ' | NumberToString( pDeleteViewsAndSubsets ) );

  AsciiOutput( sDebugFile, '            pSuppressConsol      : ' | NumberToString( pSuppressConsol) );
  AsciiOutput( sDebugFile, '            pSuppressRules        : ' | NumberToString( pSuppressRules) );

  AsciiOutput( sDebugFile, '            pAccumulate     : ' | NumberToString(pAccumulate));

  AsciiOutput( sDebugFile, '            pDropAndReattachRules     : ' | NumberToString(pDropAndReattachRules));
  AsciiOutput( sDebugFile, '            pCopyDataViaClonedCube     : ' | NumberToString(pCopyDataViaClonedCube));

  AsciiOutput( sDebugFile, '            pDebug       : ' | NumberToString( pDebug) );

EndIf;

#Convert pFactor to a number
nFactor = StringToNumber(pFactor);

# If specified cube does not exist then terminate process
If( CubeExists(   pCube   ) = 0 );
  sMessage = 'Cube: ' | pCube | ' does not exist';
  If( pDebug >= 1 );
    AsciiOutput( sDebugFile, sMessage );
  EndIf;
  nErrors = nErrors + 1;
  ItemReject( sMessage );
EndIf;

# A view name wasn't provided, so just use a timestamp
If( TRIM(pView) @= '' );
  sMessage = 'A view name was not provided';
  If( pDebug >= 1 );
    AsciiOutput( sDebugFile, sMessage );
  EndIf;
  pView = 'Bedrock.' | cRandomInt;
EndIf;

sSubset = pView;
sTargetView = 'Target '| pView;

# Check if there is a rules file to drop
# if not, ignore the pDropAndReattachRules parameter and proceed without dropping the rules
If(pDropAndReattachRules = 1);
    sRuleFile = pCube | '.rux';
    If( FileExists( sRuleFile ) <> 1 );
      If( pDebug >= 1 );
        AsciiOutput( sDebugFile, 'Rule file not found' );
      EndIf;
      pDropAndReattachRules = 0;
    EndIf;
EndIf;


# Work through the pElementMapping parameter identifying dimension names, source elements and target elements

# The pElementMapping string is in the format Dim1ToCopy:SourceElement1->TargetElement1 & Dim2ToCopy:SourceElement2->TargetElement2 etc

# That means the TargetElements need to be removed so the string can be added to pFilter so the source can b generated

# Loop through the pElementMapping parameter one character at a time
# looking for the Dim:SourceElement->TargetElement clause for each dimension to be mapped
# When the pDimensionDelim is encountered the next substring starts (on the next character)

##########################################################################################################
### Split ElementMapping parameter and create variables to be substituted ###
sElementMapping = TRIM( pElementMapping );
nChar = 1;
nCharCount = LONG( sElementMapping );

# If there's no element mapping then the process can be used to multiply existing value by a factor
If( nCharCount = 0 );
  sMessage = 'The element mapping parameter is blank';
  If( pDebug >= 1 );
    AsciiOutput( sDebugFile, sMessage );
  EndIf;
  #nErrors = nErrors + 1;
  #ItemReject( sMessage );
  Else;


  sWord = '';
  sLastDelim = '';


  # Add a trailing element delimiter so that the last element is picked up
  If( nCharCount > 0 );
    sElementMapping = sElementMapping | sMappingDelimiter ;
    nCharCount = nCharCount + LONG(sMappingDelimiter );
  EndIf;

  WHILE (nChar <= nCharCount);
    sChar = SUBST( sElementMapping, nChar, 1);
    If( pDebug >= 1 );
      sMessage = 'Next character is: ' | sChar | ' at ' | NumberToString(nChar);
      AsciiOutput( sDebugFile, sMessage );
    EndIf;

    # Used for delimiters, required for multiple character delimiters
    sDelim = '';
    nAddExtra = 0;

    # Ignore spaces
    IF (TRIM(sChar) @<> '' );

      ### Dimension Name ###

      # If the delimiter is more than 1 character peek ahead the same amount
      # Ignore the first character
      sDelim = sChar;
      nCount = LONG(sElementStartDelim) - 1;
      If( nCount > 0 & nChar + nCount <= nCharCount );
        # Add the extra characters
        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);
        # Move to the end of the delimter
        nAddExtra = nCount;
      EndIf;

      If( sDelim @= sElementStartDelim );

        sChar = sDelim;

        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );
            sMessage = 'The name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';
            If( pDebug >= 1 );
              AsciiOutput( sDebugFile, sMessage );
            EndIf;
            ItemReject(sMessage);
        EndIf;

        sDimension = sWord;

        If( pDebug >= 1 );
          sMessage = 'Found dimension name: ' | sDimension | ' at ' | NumberToString(nChar);
          AsciiOutput( sDebugFile, sMessage );
        EndIf;

        If( DimensionExists( sDimension ) = 0 );
            # The dimension does not exist in the model. Cancel process
            sMessage = 'Dimension: ' | sDimension | ' does not exist';
            If( pDebug >= 1 );
              AsciiOutput( sDebugFile, sMessage );
            EndIf;
            nErrors = nErrors + 1;
            ItemReject( sMessage );
        EndIf;

        # Check that the dimension is in the cube
         i = 1;
         iMax = 30;
         sDimInCube = 'No';
         While( i <= iMax );
           sDimensionOfCube = TabDim( pCube, i );
           If(sDimension @= sDimensionOfCube);
             sDimInCube = 'Yes';
             # record where the loop stops
             nIndex = i;
             i = 100;
                If( pDebug >= 1 );
                  AsciiOutput( sDebugFile, sDimension | ' is in the cube' );
                EndIf;
             Else;
             i = i + 1;
           EndIf;
        End;

        If( sDimInCube @<> 'Yes' );
            # The dimension does not exist in the cube. Cancel process
            sMessage = 'Dimension: ' | sDimension | ' does not exist in this cube';
            If( pDebug >= 1 );
              AsciiOutput( sDebugFile, sMessage );
            EndIf;
            nErrors = nErrors + 1;
            ItemReject( sMessage );
        EndIf;

        ### Dimension exists so add it to the filters

        IF(LONG(sFilter) > 0);
                sFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;
          sTargetFilter = sTargetFilter | sDelimDim | sDimension | sElementStartDelim;

          Else;
                sFilter = sDimension | sElementStartDelim;
          sTargetFilter = sDimension | sElementStartDelim;

        EndIf;

      #Reset the source and target elements
        sSource = '';
        sTarget = '';

        # The variable nElementCount is used to keep track of how many elements there are per dimension
        # the first element is the source
        # the second element is the target
        # There shouldn't be any more than 2 elements per dimension

        # A new dimension has been found so reset the element count so
        # the code can tell how many elements have been specified for each dimension
        # There should just be 2

        nElementCount = 1;

        #nIndex = 1;

        sLastDelim = sChar;
        # Clear the word
        sWord = '';

      Else;

        # Reset extra chars
        nAddExtra = 0;

        ### Check both dim delimiter and element delimiter ###
        nIsDelimiter = 0;

        ## Check dimension delimiter first
        # If the delimiter is more than 1 character peek ahead the same amount
        # Ignore the first character
        sDelim = sChar;
        nCount = LONG(sDelimDim) - 1;
        If( nCount > 0 & nChar + nCount <= nCharCount );
          # Add the extra characters
          sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);
          # Move to the end of the delimter
          nAddExtra = nCount;
        EndIf;

        If( sDelim @= sDelimDim );
          nIsDelimiter = 1;
          sChar = sDelim;
        Else;
          # Reset extra chars
          nAddExtra = 0;

          ## Check element delimiter

          # If the delimiter is more than 1 character peek ahead the same amount
          # Ignore the first character
          sDelim = sChar;
          nCount = LONG(sMappingDelimiter) - 1;
          If( nCount > 0 & nChar + nCount <= nCharCount );
            # Add the extra characters
            sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);
            # Move to the end of the delimter
            nAddExtra = nCount;
          EndIf;

          If( sDelim @= sMappingDelimiter  );
            nIsDelimiter = 1;
            sChar = sDelim;
          Else;
            # Reset extra chars
            nAddExtra = 0;
          EndIf;

        EndIf;

        If ( nIsDelimiter = 1 );

          If( sLastDelim @= '' % sLastDelim @= sDelimDim );
            sMessage = 'An element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';
            If( pDebug >= 1 );
              AsciiOutput( sDebugFile, sMessage );
            EndIf;
            ItemReject( sMessage );
          EndIf;


          # an element has been found!
          sElement = sWord;

          If( pDebug >= 1 );
            sMessage = 'Inserting element: ' | sElement | ' at ' | NumberToString(nChar);
            AsciiOutput( sDebugFile, sMessage );
          EndIf;

          If( DIMIX( sDimension, sElement ) = 0 );
              # The element does not exist in the dimension. Cancel process
              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';
              If( pDebug >= 1 );
                AsciiOutput( sDebugFile, sMessage );
              EndIf;
              nErrors = nErrors + 1;
              ItemReject( sMessage );
          EndIf;

          # Allow consolidations only if pSuppressConsol is not set to 1
          # Consolidations may be made allowable
          # so that you can copy strings between c levels
          # or copy from a consolidated source element to an n level target element

          If ( DTYPE( sDimension, sElement) @= 'C' & pSuppressConsol = 1);
              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension | ' is consolidated but consolidations are suppressed';
              If ( pDebug >= 1 );
                  AsciiOutput( sDebugFile, sMessage );
              EndIf;
              # Cancel process
              nErrors = nErrors + 1;
              ItemReject( sMessage );
          Else;
              # Add the element to the source or target depending on whether it's the first or the second element
              # Get principal name
              # in case source element and this element are using different aliases

              sElement = DimensionElementPrincipalName(sDimension,sElement);

              # first element
              IF(nElementCount = 1);

                sSource = sElement;

                If ( pDebug >= 1 );
                    AsciiOutput( sDebugFile, 'Inserting element ' | sElement | ' into source filter on dimension ' | sDimension);
                EndIf;
                If( pDebug <= 1 );

                    sFilter = sFilter | sElement;

                EndIf;

              # second element
              ElseIf(nElementCount = 2);

                sTarget = sElement;

                If ( pDebug >= 1 );
                    AsciiOutput( sDebugFile, 'Inserting element ' | sElement | ' into target filter on dimension ' | sDimension);
                EndIf;
                If( pDebug <= 1 );

                    sTargetFilter = sTargetFilter | sElement;

                EndIf;

              Else;
                If ( pDebug >= 1 );
                  AsciiOutput( sDebugFile, 'There should only be 2 elements per dimension, a source and a target');
                EndIf;
                # Allow process to run even if there are more than 2 elements - just ignore anything after the 2nd
              EndIf;

            If(nIndex = 1);
              nMappedDim1 = 1;
              sSourceDim1 = sSource;
              sTargetDim1 = sTarget;
              ElseIf(nIndex = 2);
                nMappedDim2 = 1;
                sSourceDim2 = sSource;
                sTargetDim2 = sTarget;
              ElseIf(nIndex = 3);
                nMappedDim3 = 1;
                sSourceDim3 = sSource;
                sTargetDim3 = sTarget;
              ElseIf(nIndex = 4);
                nMappedDim4 = 1;
                sSourceDim4 = sSource;
                sTargetDim4 = sTarget;
              ElseIf(nIndex = 5);
                nMappedDim5 = 1;
                sSourceDim5 = sSource;
                sTargetDim5 = sTarget;
              ElseIf(nIndex = 6);
                nMappedDim4 = 1;
                sSourceDim6 = sSource;
                sTargetDim6 = sTarget;
              ElseIf(nIndex = 7);
                nMappedDim7 = 1;
                sSourceDim7 = sSource;
                sTargetDim7 = sTarget;
              ElseIf(nIndex = 8);
                nMappedDim8 = 1;
                sSourceDim8 = sSource;
                sTargetDim8 = sTarget;
              ElseIf(nIndex = 9);
                nMappedDim9 = 1;
                sSourceDim9 = sSource;
                sTargetDim9 = sTarget;
              ElseIf(nIndex = 10);
                nMappedDim10 = 1;
                sSourceDim10 = sSource;
                sTargetDim10 = sTarget;
              ElseIf(nIndex = 11);
                nMappedDim11 = 1;
                sSourceDim11 = sSource;
                sTargetDim11 = sTarget;
              ElseIf(nIndex = 12);
                nMappedDim12 = 1;
                sSourceDim12 = sSource;
                sTargetDim12 = sTarget;
              ElseIf(nIndex = 13);
                nMappedDim13 = 1;
                sSourceDim13 = sSource;
                sTargetDim13 = sTarget;
              ElseIf(nIndex = 14);
                nMappedDim14 = 1;
                sSourceDim14 = sSource;
                sTargetDim14 = sTarget;
              ElseIf(nIndex = 15);
                nMappedDim15 = 1;
                sSourceDim15 = sSource;
                sTargetDim15 = sTarget;
              ElseIf(nIndex = 16);
                nMappedDim16 = 1;
                sSourceDim16 = sSource;
                sTargetDim16 = sTarget;
              ElseIf(nIndex = 17);
                nMappedDim17 = 1;
                sSourceDim17 = sSource;
                sTargetDim17 = sTarget;
              ElseIf(nIndex = 18);
                nMappedDim18 = 1;
                sSourceDim18 = sSource;
                sTargetDim18 = sTarget;
              ElseIf(nIndex = 19);
                nMappedDim19 = 1;
                sSourceDim19 = sSource;
                sTargetDim19 = sTarget;
              ElseIf(nIndex = 20);
                nMappedDim20 = 1;
                sSourceDim20 = sSource;
                sTargetDim20 = sTarget;
              ElseIf(nIndex = 21);
                nMappedDim21 = 1;
                sSourceDim21 = sSource;
                sTargetDim21 = sTarget;
              ElseIf(nIndex = 22);
                nMappedDim22 = 1;
                sSourceDim22 = sSource;
                sTargetDim22 = sTarget;
              ElseIf(nIndex = 23);
                nMappedDim23 = 1;
                sSourceDim23 = sSource;
                sTargetDim23 = sTarget;
              ElseIf(nIndex = 24);
                nMappedDim24 = 1;
                sSourceDim24 = sSource;
                sTargetDim24 = sTarget;
              ElseIf(nIndex = 25);
                nMappedDim25 = 1;
                sSourceDim25 = sSource;
                sTargetDim25 = sTarget;
              ElseIf(nIndex = 26);
                nMappedDim26 = 1;
                sSourceDim26 = sSource;
                sTargetDim26 = sTarget;
              ElseIf(nIndex = 27);
                nMappedDim27 = 1;
                sSourceDim27 = sSource;
                sTargetDim27 = sTarget;

            EndIf;

          # end if for what to do if element found
          EndIf;


          sLastDelim = sChar;

          # Clear the word
          sWord = '';

          nElementCount = nElementCount + 1;

        Else;
          sWord = sWord | sChar;
        EndIf;

      EndIf;

    EndIf;

    nChar = nChar + nAddExtra + 1;

    If( pDebug >= 1 );
      sMessage = 'Current word is: ' | sWord | ' at ' | NumberToString(nChar - 1);
      AsciiOutput( sDebugFile, sMessage );
    EndIf;


  END;
ENDIF;
#################################################################################################################################

### Determine number of the dimensions with the elements to copy in the target cube ###
nCount = 1;

While( TabDim( pCube, nCount ) @<> '' );
  nCount = nCount + 1;
End;
nDimensionCount = nCount - 1;

If( nDimensionCount > 27 );
  nErrors = 1;
  If( pDebug >= 1 );
    sMessage = 'Cube has too many dimensions: ' | pCube | ' max 27 dimensions.';
    AsciiOutput( sDebugFile, sMessage );
  EndIf;
  DataSourceType = 'NULL';
  ProcessQuit;
EndIf;

### Check that there if a dimension is used, there is a source element and a target element
nCounter = 1;
WHILE(nCounter <= nDimensionCount);

  sMappedDimVariable = 'nMappedDim ' | NumberToString(nCounter);
  sDimensionUsedPadded = Expand('%' | sMappedDimVariable | '%');

  nMappedDim = StringToNumber(Trim(sDimensionUsedPadded));
  If(nMappedDim = 1);
    sDim = TabDim( pCube, nCounter );
    sSourceVariable = cSourceVariableStem | NumberToString(nCounter);
    sSourcePadded = Expand('%' | sSourceVariable | '%');
    sSource = Trim(sSourcePadded);

    sTargetVariable = cTargetVariableStem | NumberToString(nCounter);
    sTargetPadded = Expand('%' | sTargetVariable | '%');
    sTarget = Trim(sTargetPadded);

    If(sSource @='' % sTarget @='');
      sMessage = 'Source and/or target element is blank for dimension ' | sDim;
      If( pDebug >= 1 );
        AsciiOutput( sDebugFile, sMessage );
      EndIf;
      nErrors = nErrors + 1;
    EndIf;

  EndIf;

nCounter = nCounter + 1;

END;

### Create View of target to zero out
# Check that there's something in sTargetFilter so the cube doesn't accidentally get wiped out


If(nErrors = 0);
  If( pDebug >= 1 );
    AsciiOutput( sDebugFile, 'Filter for target view is ' | sTargetFilter );
  EndIf;

  If(pZeroTarget = 1 & LONG(sTargetFilter)> 0);

    ExecuteProcess('Bedrock.Cube.View.Create',
    'pCube',pCube,
    'pView', sTargetView,
    'pFilter', sTargetFilter,
    'pSuppressZero',1,
    'pSuppressConsol', pSuppressConsol,
    'pSuppressRules', pSuppressRules,
    'pDimensionDelim', pDimensionDelim,
    'pElementStartDelim', pElementStartDelim,
    'pElementDelim', pElementDelim,
    'pDebug', pDebug);

    If( pDebug <= 1 );
      ViewZeroOut(pCube, sTargetView);
    EndIf;
  EndIf;
  ### Create View of Source ###

  If( pDebug >= 1 );
    AsciiOutput( sDebugFile, 'Filter for source view is ' | sFilter );
  EndIf;

  ExecuteProcess('Bedrock.Cube.View.Create',
    'pCube',pCube,
    'pView', pView,
    'pFilter', sFilter,
    'pSuppressZero',1,
    'pSuppressConsol', pSuppressConsol,
    'pSuppressRules', pSuppressRules,
    'pDimensionDelim', pDimensionDelim,
    'pElementStartDelim', pElementStartDelim,
    'pElementDelim', pElementDelim,
    'pDebug', pDebug);

    # Validate View
      If( ViewExists( pCube, pView ) = 0 );
        nErrors = nErrors + 1;
        sMessage = 'There was a problem creating view: ' | pView | ' for cube: ' | pCube;
        If( pDebug >= 1 );
          AsciiOutput( sDebugFile, sMessage );
        EndIf;
        DataSourceType = 'NULL';
        ItemReject( sMessage );
      EndIf;

  ### Assign Datasource ###

  # Set the parameter pCopyDataViaClonedCube to 1
  # to avoid recalculating the cache each time a cell is copied
  # Calculated values can be copied to a tempororary cloned cube
  # then the rules can be dropped, the data can be copied
  # and then the rules can be reattached on the epilog

  sClonedCube = pCube | cUser | cRandomInt;

  If(pCopyDataViaClonedCube = 1 & pDebug <= 1);

    # Note that pSuppressRules = 1 to skip rules
    # The Bedrock Cube Clone process uses 1 for the pRuleValues parameter to skip rules
    # So pSuppressRules can be passed to pRuleValues

    ExecuteProcess('Bedrock.Cube.Clone',
      'pSourceCube', pCube,
      'pTargetCube', sClonedCube,
      'pIncludeRules', 0,
      'pIncludeData', 1,
      'pSourceView', pView,
      'pRuleValues', pSuppressRules,
      'pDebug', pDebug);

    nCubeCloned = 1;

    # Create view in cloned cube
    ExecuteProcess('Bedrock.Cube.View.Create',
      'pCube', sClonedCube,
      'pView', pView,
      'pFilter', sFilter,
      'pSuppressZero',1,
      'pSuppressConsol', pSuppressConsol,
      'pSuppressRules', pSuppressRules,
      'pDimensionDelim', pDimensionDelim,
      'pElementStartDelim', pElementStartDelim,
      'pElementDelim', pElementDelim,
      'pDebug', pDebug);

    DataSourceType = 'VIEW';
    DatasourceNameForServer = sClonedCube;
    DatasourceNameForClient = sClonedCube;
    DatasourceCubeView = pView;

    Else;

    DataSourceType = 'VIEW';
    DatasourceNameForServer = pCube;
    DatasourceNameForClient = pCube;
    DatasourceCubeView = pView;

  EndIf;

  # This code will comment out the rules file while the process is running
  If(pDropAndReattachRules = 1 & pDebug <= 1);
    # Check whether calculated values are to be skipped
    If(pSuppressRules = 1);
      nRulesDropped = 1;
      ExecuteProcess('Bedrock.Cube.DropRules','pCube',pCube,'pDebug',pDebug);
    EndIf;
  EndIf;
  # End of code to drop rules
  Else;
  DataSourceType = 'NULL';

EndIf;




#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****



### Determine target dimension substitution ###

# The If statements below look up each variable to see if it has been mapped to something else
# This is not a nested if statement because there may be mappings on more than 1 dimension

# Set debug file name
sDebugFile = cDebugFile | 'Data.debug';

#If( pDebug >= 1 );
#  ASCIIOutput( sDebugFile, 'Before Update',pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
#ENDIF;


### Check for errors in prolog ###

#If nErrors > 0 data source is null


IF(nMappedDim1 = 1);
  IF(v1 @= sSourceDim1);
    v1 = sTargetDim1;
  EndIf;
EndIf;

IF(nMappedDim2 = 1);
  IF(v2 @= sSourceDim2);
    v2 = sTargetDim2;
  EndIf;
EndIf;

IF(nMappedDim3 = 1);
  IF(v3 @= sSourceDim3);
    v3 = sTargetDim3;
  EndIf;
EndIf;

IF(nMappedDim4 = 1);
  IF(v4 @= sSourceDim4);
    v4 = sTargetDim4;
  EndIf;
EndIf;

IF(nMappedDim5 = 1);
  IF(v5 @= sSourceDim5);
    v5 = sTargetDim5;
  EndIf;
EndIf;

IF(nMappedDim6 = 1);
  IF(v6 @= sSourceDim6);
    v6 = sTargetDim6;
  EndIf;
EndIf;

IF(nMappedDim7 = 1);
  IF(v7 @= sSourceDim7);
    v7 = sTargetDim7;
  EndIf;
EndIf;

IF(nMappedDim8 = 1);
  IF(v8 @= sSourceDim8);
    v8 = sTargetDim8;
  EndIf;
EndIf;

IF(nMappedDim9 = 1);
  IF(v9 @= sSourceDim9);
    v9 = sTargetDim9;
  EndIf;
EndIf;

IF(nMappedDim10 = 1);
  IF(v10 @= sSourceDim10);
    v10 = sTargetDim10;
  EndIf;
EndIf;

IF(nMappedDim11 = 1);
  IF(v11 @= sSourceDim11);
    v11 = sTargetDim11;
  EndIf;
EndIf;

IF(nMappedDim12 = 1);
  IF(v12 @= sSourceDim12);
    v12 = sTargetDim12;
  EndIf;
EndIf;

IF(nMappedDim13 = 1);
  IF(v13 @= sSourceDim13);
    v13 = sTargetDim13;
  EndIf;
EndIf;

IF(nMappedDim14 = 1);
  IF(v14 @= sSourceDim14);
    v14 = sTargetDim14;
  EndIf;
EndIf;

IF(nMappedDim15 = 1);
  IF(v15 @= sSourceDim15);
    v15 = sTargetDim15;
  EndIf;
EndIf;

IF(nMappedDim16 = 1);
  IF(v16 @= sSourceDim16);
    v16 = sTargetDim16;
  EndIf;
EndIf;

IF(nMappedDim17 = 1);
  IF(v17 @= sSourceDim17);
    v17 = sTargetDim17;
  EndIf;
EndIf;

IF(nMappedDim18 = 1);
  IF(v18 @= sSourceDim18);
    v18 = sTargetDim18;
  EndIf;
EndIf;

IF(nMappedDim19 = 1);
  IF(v19 @= sSourceDim19);
    v19 = sTargetDim19;
  EndIf;
EndIf;

IF(nMappedDim20 = 1);
  IF(v20 @= sSourceDim20);
    v20 = sTargetDim20;
  EndIf;
EndIf;

IF(nMappedDim21 = 1);
  IF(v21 @= sSourceDim21);
    v21 = sTargetDim21;
  EndIf;
EndIf;

IF(nMappedDim22 = 1);
  IF(v22 @= sSourceDim22);
    v22 = sTargetDim22;
  EndIf;
EndIf;

IF(nMappedDim23 = 1);
  IF(v23 @= sSourceDim23);
    v23 = sTargetDim23;
  EndIf;
EndIf;

IF(nMappedDim24 = 1);
  IF(v24 @= sSourceDim24);
    v24 = sTargetDim24;
  EndIf;
EndIf;

IF(nMappedDim25 = 1);
  IF(v25 @= sSourceDim25);
    v25 = sTargetDim25;
  EndIf;
EndIf;

IF(nMappedDim26 = 1);
  IF(v26 @= sSourceDim26);
    v26 = sTargetDim26;
  EndIf;
EndIf;

IF(nMappedDim27 = 1);
  IF(v27 @= sSourceDim27);
    v27 = sTargetDim27;
  EndIf;
EndIf;
### End of determining target substitution ###

### Write data from source file to target cube ###
If( pDebug <= 1 );
  If( nDimensionCount = 2 );
    If( CellIsUpdateable( pCube, v1, v2 ) = 1 );
      sElType = DType( sDim2, v2 );
      IF( sElType @= 'AS' % sElType @= 'AA');
        CellPutS( v3, pCube, v1, v2 );
      ELSEIF( sElType @= 'AN' );
        CellPutN( Numbr( v3) * nFactor, pCube, v1, v2 );
      ElseIf( sElType @= 'S' );
        CellPutS( v3, pCube, v1, v2 );
      Else;
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2 );
          nCbal = nObal + Numbr( v3 ) * nFactor;
        ELSE;
          nCbal = Numbr( v3 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 3 );
    If( CellIsUpdateable( pCube, v1, v2, v3 ) = 1 );
      sElType = DType( sDim3, v3 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3 );
          nCbal = nObal + Numbr( v4 ) * nFactor;
        ELSE;
          nCbal = Numbr( v4 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3 );
      Else;
        CellPutS( v4, pCube, v1, v2, v3 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 4 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4 ) = 1 );
      sElType = DType( sDim4, v4 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4);
          nCbal = nObal + Numbr( v5 ) * nFactor;
        ELSE;
          nCbal = Numbr( v5 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4);
      Else;
        CellPutS( v5, pCube, v1, v1, v2, v3, v4);
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 5 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5 ) = 1 );
      sElType = DType( sDim5, v5 );
      If( sElType @<> 'S' );
        IF(pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5 );
          nCbal = nObal + Numbr( v6 ) * nFactor;
        ELSE;
          nCbal = Numbr( v6 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5 );
      Else;
        CellPutS( v6, pCube, v1, v2, v3, v4, v5 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 6 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6 ) = 1 );
      sElType = DType( sDim6, v6 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6 );
          nCbal = nObal + Numbr( v7 ) * nFactor;
        ELSE;
          nCbal = Numbr( v7 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6 );
      Else;
        CellPutS( v7, pCube, v1, v2, v3, v4, v5, v6 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 7 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7 ) = 1 );
      sElType = DType( sDim7, v7 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7 );
          nCbal = nObal + Numbr( v8 ) * nFactor;
        ELSE;
          nCbal = Numbr( v8 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7 );
      Else;
        CellPutS( v8, pCube, v1, v2, v3, v4, v5, v6, v7 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 8 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8 ) = 1 );
      sElType = DType( sDim8, v8 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8 );
          nCbal = nObal + Numbr( v9 ) * nFactor;
        ELSE;
          nCbal = Numbr( v9 )* nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );
      Else;
        CellPutS( v9, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 9 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 ) = 1 );
      sElType = DType( sDim9, v9 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );
          nCbal = nObal + Numbr( v10 ) * nFactor;
        ELSE;
          nCbal = Numbr( v10 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );
      Else;
        CellPutS( v10, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 10 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) = 1 );
      sElType = DType( sDim10, v10 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );
          nCbal = nObal + Numbr( v11 ) * nFactor;
        ELSE;
          nCbal = Numbr( v11 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );
      Else;
        CellPutS( v11, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 11 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 ) = 1 );
      sElType = DType( sDim11, v11 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );
          nCbal = nObal + Numbr( v12 ) * nFactor;
        ELSE;
          nCbal = Numbr( v12 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );
      Else;
        CellPutS( v12, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 12 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 ) = 1 );
      sElType = DType( sDim12, v12 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );
          nCbal = nObal + Numbr( v13 ) * nFactor;
        ELSE;
          nCbal = Numbr( v13 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );
      Else;
        CellPutS( v13, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 13 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );
      sElType = DType( sDim13, v13 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );
          nCbal = nObal + Numbr( v14 ) * nFactor;
        ELSE;
          nCbal = Numbr( v14 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );
      Else;
        CellPutS( v14, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 14 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 ) = 1 );
      sElType = DType( sDim14, v14 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );
          nCbal = nObal + Numbr( v15 ) * nFactor;
        ELSE;
          nCbal = Numbr( v15 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );
      Else;
        CellPutS( v15, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 15 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 ) = 1 );
      sElType = DType( sDim15, v15 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );
          nCbal = nObal + Numbr( v16 ) * nFactor;
        ELSE;
          nCbal = Numbr( v16 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );
      Else;
        CellPutS( v16, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 16 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 ) = 1 );
      sElType = DType( sDim16, v16 );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );
          nCbal = nObal + Numbr( v17 ) * nFactor;
        ELSE;
          nCbal = Numbr( v17 ) * nFactor;
        Endif;
      If( sElType @<> 'S' );
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );
      Else;
        CellPutS( v17, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 17 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 ) = 1 );
      sElType = DType( sDim17, v17 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );
          nCbal = nObal + Numbr( v18 ) * nFactor;
        ELSE;
          nCbal = Numbr( v18 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );
      Else;
        CellPutS( v18, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 18 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 ) = 1 );
      sElType = DType( sDim18, v18 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );
          nCbal = nObal + Numbr( v19 ) * nFactor;
        ELSE;
          nCbal = Numbr( v19 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );
      Else;
        CellPutS( v19, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 19 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 ) = 1 );
      sElType = DType( sDim19, v19 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );
          nCbal = nObal + Numbr( v20 ) * nFactor;
        ELSE;
          nCbal = Numbr( v20 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );
      Else;
        CellPutS( v20, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 20 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 ) = 1 );
      sElType = DType( sDim20, v20 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );
          nCbal = nObal + Numbr( v21 ) * nFactor;
        ELSE;
          nCbal = Numbr( v21 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );
      Else;
        CellPutS( v21, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 21 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 ) = 1 );
      sElType = DType( sDim21, v21 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );
          nCbal = nObal + Numbr( v22 ) * nFactor;
        ELSE;
          nCbal = Numbr( v22 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );
      Else;
        CellPutS( v22, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 22 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 ) = 1 );
      sElType = DType( sDim22, v22 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );
          nCbal = nObal + Numbr( v23 ) * nFactor;
        ELSE;
          nCbal = Numbr( v23 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );
      Else;
        CellPutS( v23, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 23 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
    v22, v23 ) = 1 );
      sElType = DType( sDim23, v23 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
            v22, v23 );
          nCbal = nObal + Numbr( v24 ) * nFactor;
        ELSE;
          nCbal = Numbr( v24 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23 );
      Else;
        CellPutS( v24, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 24 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24 ) = 1 );
      sElType = DType( sDim24, v24 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
            v22, v23, v24 );
          nCbal = nObal + Numbr( v25 ) * nFactor;
        ELSE;
          nCbal = Numbr( v25 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23, v24 );
      Else;
        CellPutS( v25, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23, v24 );
      EndIf;
    EndIf;
  ElseIf( nDimensionCount = 25 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24, v25 ) = 1 );
      sElType = DType( sDim25, v25 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
            v22, v23, v24, v25 );
          nCbal = nObal + Numbr( v26 ) * nFactor;
        ELSE;
          nCbal = Numbr( v26 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23, v24, v25 );
      Else;
        CellPutS( v26, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23, v24, v25 );
      EndIf;
    EndIf;
ElseIf( nDimensionCount = 26 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
    v22, v23, v24, v25, v26 ) = 1 );
      sElType = DType( sDim26, v26 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
            v22, v23, v24, v25, v26 );
          nCbal = nObal + Numbr( v27 ) * nFactor;
        ELSE;
          nCbal = Numbr( v27 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
        v22, v23, v24, v25, v26 );
      Else;
        CellPutS( v27, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,
          v21, v22, v23, v24, v25, v26 );
      EndIf;
    EndIf;
ElseIf( nDimensionCount = 27 );
    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
    v22, v23, v24, v25, v26, v27 ) = 1 );
      sElType = DType( sDim27, v27 );
      If( sElType @<> 'S' );
        IF(
        pAccumulate >= 1);
          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
            v22, v23, v24, v25, v26, v27 );
          nCbal = nObal + Numbr( v28 ) * nFactor;
        ELSE;
          nCbal = Numbr( v28 ) * nFactor;
        Endif;
        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
          v22, v23, v24, v25, v26, v27 );
      Else;
        CellPutS( v28, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,
          v21, v22, v23, v24, v25, v26, v27 );
      EndIf;
    EndIf;

  EndIf;
EndIf;

#If( pDebug >= 1 );
#  ASCIIOutput( sDebugFile, 'After Update',pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
#ENDIF;


#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

#####################################################################################
##~~Copyright bedrocktm1.org 2011 www.bedrocktm1.org/how-to-licence.php Ver 1.0.0~~##
#####################################################################################

#If the rules were dropped, reattach them
If(nRulesDropped = 1);
  ExecuteProcess('Bedrock.Cube.AttachRules','pCube',pCube,'pDebug',pDebug);
EndIf;

If(CubeExists(sClonedCube) = 1);
  CubeDestroy(sClonedCube);
EndIf;

# Set debug file name
sDebugFile = cDebugFile | 'Epilog.debug';

If(nErrors = 0);

  If(pDebug <= 1 );
    # Zero out source data #

    If( pZeroSource = 1 );
      # Don't accidentally wipe out the cube!
      If(LONG(sFilter) > 0);
        ViewZeroOut( pCube, pView );
      EndIF;
    EndIf;
  EndIf;

    ### Destroy temporary views and subsets ###
#    If(pDeleteViewsAndSubsets <> 0);
#      # Delete source view
#      ExecuteProcess('Bedrock.Cube.View.DeleteWithSubsets',
#        'pCube', pCube,
#        'pView', pView,
#        'pMode', pDeleteViewsAndSubsets,
#        'pDebug', pDebug);
#
#      # Delete target view
#      ExecuteProcess('Bedrock.Cube.View.DeleteWithSubsets',
#        'pCube', pCube,
#        'pView', sTargetView,
#        'pMode', pDeleteViewsAndSubsets,
#        'pDebug', pDebug);
#    EndIf;

ENDIF;


### Initialise Debug ###

If( pDebug >= 1 );



  # Log errors
  If( nErrors <> 0 );
    AsciiOutput( sDebugFile, 'Errors Occurred' );
  EndIf;

  # Log finish time
  AsciiOutput( sDebugFile, 'Process Finished: ' | TimSt( Now, '\d-\m-\Y \h:\i:\s' ) );

EndIf;


### If errors occurred terminate process with a major error status ###

If( nErrors <> 0 );
  ProcessQuit;
EndIf;


### End Epilog ###




#endregion